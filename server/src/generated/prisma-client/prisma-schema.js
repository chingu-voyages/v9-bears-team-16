module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateColors {
  count: Int!
}

type AggregateFonts {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateTheme {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Colors {
  id: ID!
  primaryLight: String!
  primaryDark: String!
  accentLight: String!
  accentDark: String!
  accentBrand: String!
}

type ColorsConnection {
  pageInfo: PageInfo!
  edges: [ColorsEdge]!
  aggregate: AggregateColors!
}

input ColorsCreateInput {
  id: ID
  primaryLight: String!
  primaryDark: String!
  accentLight: String!
  accentDark: String!
  accentBrand: String!
}

input ColorsCreateOneInput {
  create: ColorsCreateInput
  connect: ColorsWhereUniqueInput
}

type ColorsEdge {
  node: Colors!
  cursor: String!
}

enum ColorsOrderByInput {
  id_ASC
  id_DESC
  primaryLight_ASC
  primaryLight_DESC
  primaryDark_ASC
  primaryDark_DESC
  accentLight_ASC
  accentLight_DESC
  accentDark_ASC
  accentDark_DESC
  accentBrand_ASC
  accentBrand_DESC
}

type ColorsPreviousValues {
  id: ID!
  primaryLight: String!
  primaryDark: String!
  accentLight: String!
  accentDark: String!
  accentBrand: String!
}

type ColorsSubscriptionPayload {
  mutation: MutationType!
  node: Colors
  updatedFields: [String!]
  previousValues: ColorsPreviousValues
}

input ColorsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ColorsWhereInput
  AND: [ColorsSubscriptionWhereInput!]
  OR: [ColorsSubscriptionWhereInput!]
  NOT: [ColorsSubscriptionWhereInput!]
}

input ColorsUpdateDataInput {
  primaryLight: String
  primaryDark: String
  accentLight: String
  accentDark: String
  accentBrand: String
}

input ColorsUpdateInput {
  primaryLight: String
  primaryDark: String
  accentLight: String
  accentDark: String
  accentBrand: String
}

input ColorsUpdateManyMutationInput {
  primaryLight: String
  primaryDark: String
  accentLight: String
  accentDark: String
  accentBrand: String
}

input ColorsUpdateOneRequiredInput {
  create: ColorsCreateInput
  update: ColorsUpdateDataInput
  upsert: ColorsUpsertNestedInput
  connect: ColorsWhereUniqueInput
}

input ColorsUpsertNestedInput {
  update: ColorsUpdateDataInput!
  create: ColorsCreateInput!
}

input ColorsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  primaryLight: String
  primaryLight_not: String
  primaryLight_in: [String!]
  primaryLight_not_in: [String!]
  primaryLight_lt: String
  primaryLight_lte: String
  primaryLight_gt: String
  primaryLight_gte: String
  primaryLight_contains: String
  primaryLight_not_contains: String
  primaryLight_starts_with: String
  primaryLight_not_starts_with: String
  primaryLight_ends_with: String
  primaryLight_not_ends_with: String
  primaryDark: String
  primaryDark_not: String
  primaryDark_in: [String!]
  primaryDark_not_in: [String!]
  primaryDark_lt: String
  primaryDark_lte: String
  primaryDark_gt: String
  primaryDark_gte: String
  primaryDark_contains: String
  primaryDark_not_contains: String
  primaryDark_starts_with: String
  primaryDark_not_starts_with: String
  primaryDark_ends_with: String
  primaryDark_not_ends_with: String
  accentLight: String
  accentLight_not: String
  accentLight_in: [String!]
  accentLight_not_in: [String!]
  accentLight_lt: String
  accentLight_lte: String
  accentLight_gt: String
  accentLight_gte: String
  accentLight_contains: String
  accentLight_not_contains: String
  accentLight_starts_with: String
  accentLight_not_starts_with: String
  accentLight_ends_with: String
  accentLight_not_ends_with: String
  accentDark: String
  accentDark_not: String
  accentDark_in: [String!]
  accentDark_not_in: [String!]
  accentDark_lt: String
  accentDark_lte: String
  accentDark_gt: String
  accentDark_gte: String
  accentDark_contains: String
  accentDark_not_contains: String
  accentDark_starts_with: String
  accentDark_not_starts_with: String
  accentDark_ends_with: String
  accentDark_not_ends_with: String
  accentBrand: String
  accentBrand_not: String
  accentBrand_in: [String!]
  accentBrand_not_in: [String!]
  accentBrand_lt: String
  accentBrand_lte: String
  accentBrand_gt: String
  accentBrand_gte: String
  accentBrand_contains: String
  accentBrand_not_contains: String
  accentBrand_starts_with: String
  accentBrand_not_starts_with: String
  accentBrand_ends_with: String
  accentBrand_not_ends_with: String
  AND: [ColorsWhereInput!]
  OR: [ColorsWhereInput!]
  NOT: [ColorsWhereInput!]
}

input ColorsWhereUniqueInput {
  id: ID
}

type Fonts {
  id: ID!
  primary: String!
  secondary: String!
}

type FontsConnection {
  pageInfo: PageInfo!
  edges: [FontsEdge]!
  aggregate: AggregateFonts!
}

input FontsCreateInput {
  id: ID
  primary: String!
  secondary: String!
}

input FontsCreateOneInput {
  create: FontsCreateInput
  connect: FontsWhereUniqueInput
}

type FontsEdge {
  node: Fonts!
  cursor: String!
}

enum FontsOrderByInput {
  id_ASC
  id_DESC
  primary_ASC
  primary_DESC
  secondary_ASC
  secondary_DESC
}

type FontsPreviousValues {
  id: ID!
  primary: String!
  secondary: String!
}

type FontsSubscriptionPayload {
  mutation: MutationType!
  node: Fonts
  updatedFields: [String!]
  previousValues: FontsPreviousValues
}

input FontsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FontsWhereInput
  AND: [FontsSubscriptionWhereInput!]
  OR: [FontsSubscriptionWhereInput!]
  NOT: [FontsSubscriptionWhereInput!]
}

input FontsUpdateDataInput {
  primary: String
  secondary: String
}

input FontsUpdateInput {
  primary: String
  secondary: String
}

input FontsUpdateManyMutationInput {
  primary: String
  secondary: String
}

input FontsUpdateOneRequiredInput {
  create: FontsCreateInput
  update: FontsUpdateDataInput
  upsert: FontsUpsertNestedInput
  connect: FontsWhereUniqueInput
}

input FontsUpsertNestedInput {
  update: FontsUpdateDataInput!
  create: FontsCreateInput!
}

input FontsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  primary: String
  primary_not: String
  primary_in: [String!]
  primary_not_in: [String!]
  primary_lt: String
  primary_lte: String
  primary_gt: String
  primary_gte: String
  primary_contains: String
  primary_not_contains: String
  primary_starts_with: String
  primary_not_starts_with: String
  primary_ends_with: String
  primary_not_ends_with: String
  secondary: String
  secondary_not: String
  secondary_in: [String!]
  secondary_not_in: [String!]
  secondary_lt: String
  secondary_lte: String
  secondary_gt: String
  secondary_gte: String
  secondary_contains: String
  secondary_not_contains: String
  secondary_starts_with: String
  secondary_not_starts_with: String
  secondary_ends_with: String
  secondary_not_ends_with: String
  AND: [FontsWhereInput!]
  OR: [FontsWhereInput!]
  NOT: [FontsWhereInput!]
}

input FontsWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createColors(data: ColorsCreateInput!): Colors!
  updateColors(data: ColorsUpdateInput!, where: ColorsWhereUniqueInput!): Colors
  updateManyColorses(data: ColorsUpdateManyMutationInput!, where: ColorsWhereInput): BatchPayload!
  upsertColors(where: ColorsWhereUniqueInput!, create: ColorsCreateInput!, update: ColorsUpdateInput!): Colors!
  deleteColors(where: ColorsWhereUniqueInput!): Colors
  deleteManyColorses(where: ColorsWhereInput): BatchPayload!
  createFonts(data: FontsCreateInput!): Fonts!
  updateFonts(data: FontsUpdateInput!, where: FontsWhereUniqueInput!): Fonts
  updateManyFontses(data: FontsUpdateManyMutationInput!, where: FontsWhereInput): BatchPayload!
  upsertFonts(where: FontsWhereUniqueInput!, create: FontsCreateInput!, update: FontsUpdateInput!): Fonts!
  deleteFonts(where: FontsWhereUniqueInput!): Fonts
  deleteManyFontses(where: FontsWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createTheme(data: ThemeCreateInput!): Theme!
  updateTheme(data: ThemeUpdateInput!, where: ThemeWhereUniqueInput!): Theme
  updateManyThemes(data: ThemeUpdateManyMutationInput!, where: ThemeWhereInput): BatchPayload!
  upsertTheme(where: ThemeWhereUniqueInput!, create: ThemeCreateInput!, update: ThemeUpdateInput!): Theme!
  deleteTheme(where: ThemeWhereUniqueInput!): Theme
  deleteManyThemes(where: ThemeWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Post {
  id: ID!
  published: Boolean!
  title: String!
  content: String!
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  id: ID
  published: Boolean
  title: String!
  content: String!
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  published_ASC
  published_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
}

type PostPreviousValues {
  id: ID!
  published: Boolean!
  title: String!
  content: String!
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateInput {
  published: Boolean
  title: String
  content: String
}

input PostUpdateManyMutationInput {
  published: Boolean
  title: String
  content: String
}

input PostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  published: Boolean
  published_not: Boolean
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Query {
  colors(where: ColorsWhereUniqueInput!): Colors
  colorses(where: ColorsWhereInput, orderBy: ColorsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Colors]!
  colorsesConnection(where: ColorsWhereInput, orderBy: ColorsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ColorsConnection!
  fonts(where: FontsWhereUniqueInput!): Fonts
  fontses(where: FontsWhereInput, orderBy: FontsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fonts]!
  fontsesConnection(where: FontsWhereInput, orderBy: FontsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FontsConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  theme(where: ThemeWhereUniqueInput!): Theme
  themes(where: ThemeWhereInput, orderBy: ThemeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Theme]!
  themesConnection(where: ThemeWhereInput, orderBy: ThemeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ThemeConnection!
  node(id: ID!): Node
}

type Subscription {
  colors(where: ColorsSubscriptionWhereInput): ColorsSubscriptionPayload
  fonts(where: FontsSubscriptionWhereInput): FontsSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  theme(where: ThemeSubscriptionWhereInput): ThemeSubscriptionPayload
}

type Theme {
  id: ID!
  title: String!
  description: String!
  colors: Colors!
  font: Fonts!
}

type ThemeConnection {
  pageInfo: PageInfo!
  edges: [ThemeEdge]!
  aggregate: AggregateTheme!
}

input ThemeCreateInput {
  id: ID
  title: String!
  description: String!
  colors: ColorsCreateOneInput!
  font: FontsCreateOneInput!
}

type ThemeEdge {
  node: Theme!
  cursor: String!
}

enum ThemeOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
}

type ThemePreviousValues {
  id: ID!
  title: String!
  description: String!
}

type ThemeSubscriptionPayload {
  mutation: MutationType!
  node: Theme
  updatedFields: [String!]
  previousValues: ThemePreviousValues
}

input ThemeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ThemeWhereInput
  AND: [ThemeSubscriptionWhereInput!]
  OR: [ThemeSubscriptionWhereInput!]
  NOT: [ThemeSubscriptionWhereInput!]
}

input ThemeUpdateInput {
  title: String
  description: String
  colors: ColorsUpdateOneRequiredInput
  font: FontsUpdateOneRequiredInput
}

input ThemeUpdateManyMutationInput {
  title: String
  description: String
}

input ThemeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  colors: ColorsWhereInput
  font: FontsWhereInput
  AND: [ThemeWhereInput!]
  OR: [ThemeWhereInput!]
  NOT: [ThemeWhereInput!]
}

input ThemeWhereUniqueInput {
  id: ID
}
`
      }
    